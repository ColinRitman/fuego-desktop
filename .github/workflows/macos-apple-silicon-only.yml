name: macOS Apple Silicon Only

on:
  push:
    branches:
      - "**"
    tags-ignore:
      - "*" # We don't want this to run on release
  pull_request:

jobs:
  macos-apple-silicon-only:
    name: macOS Apple Silicon Only
    runs-on: macos-14  # Apple Silicon runner
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies and rebuild Boost with libc++
        run: |
          # Install dependencies
          brew install libqrencode miniupnpc boost
          
          # ULTIMATE FINAL SOLUTION: Build custom Boost and override compiler paths
          echo "=== ULTIMATE FINAL SOLUTION: Build custom Boost and override compiler paths ==="
          
          # Download and build Boost from source with libc++
          cd /tmp
          wget https://sourceforge.net/projects/boost/files/boost/1.82.0/boost_1_82_0.tar.gz/download -O boost_1_82_0.tar.gz
          tar -xzf boost_1_82_0.tar.gz
          cd boost_1_82_0
          
          # Configure Boost to use libc++
          ./bootstrap.sh --with-toolset=clang
          ./b2 toolset=clang cxxflags="-stdlib=libc++" linkflags="-stdlib=libc++" --prefix=/opt/homebrew/opt/boost-custom --with-filesystem --with-thread --with-date_time --with-chrono --with-regex --with-serialization --with-program_options install
          
          # Set environment variables to use our custom Boost
          echo "BOOST_ROOT=/opt/homebrew/opt/boost-custom" >> $GITHUB_ENV
          echo "BOOST_INCLUDEDIR=/opt/homebrew/opt/boost-custom/include" >> $GITHUB_ENV
          echo "BOOST_LIBRARYDIR=/opt/homebrew/opt/boost-custom/lib" >> $GITHUB_ENV
          echo "CMAKE_PREFIX_PATH=/opt/homebrew/opt/boost-custom:$CMAKE_PREFIX_PATH" >> $GITHUB_ENV
          echo "Boost_DIR=/opt/homebrew/opt/boost-custom/lib/cmake/Boost-1.82.0" >> $GITHUB_ENV
          
          # Override compiler include paths to force our custom Boost
          echo "CPPFLAGS=-I/opt/homebrew/opt/boost-custom/include" >> $GITHUB_ENV
          echo "CXXFLAGS=-I/opt/homebrew/opt/boost-custom/include -stdlib=libc++" >> $GITHUB_ENV
          echo "LDFLAGS=-L/opt/homebrew/opt/boost-custom/lib -stdlib=libc++" >> $GITHUB_ENV
          
          # Verify our custom Boost is present
          echo "Custom Boost headers:"
          ls -la /opt/homebrew/opt/boost-custom/include/boost/math/special_functions/round.hpp || echo "Custom Boost headers not found"
          
          # Verify Boost libraries were built
          echo "Custom Boost libraries:"
          ls -la /opt/homebrew/opt/boost-custom/lib/libboost_*.dylib || echo "Custom Boost libraries not found"
          
          # Also verify system Boost libraries as fallback
          echo "System Boost libraries:"
          ls -la /opt/homebrew/lib/libboost_*.dylib || echo "System Boost libraries not found"
          
          echo "ULTIMATE FINAL SOLUTION: Built custom Boost and set compiler overrides"

      - name: Install Qt
        run: |
          # Install Qt5 via Homebrew directly
          brew install qt@5
          # Set Qt paths manually
          QT_PREFIX=$(brew --prefix qt@5)
          echo "Qt5_DIR=$QT_PREFIX/lib/cmake/Qt5" >> $GITHUB_ENV
          echo "CMAKE_PREFIX_PATH=$QT_PREFIX" >> $GITHUB_ENV
          echo "PATH=$QT_PREFIX/bin:$PATH" >> $GITHUB_ENV
          echo "Installed Qt5 via Homebrew at: $QT_PREFIX"
          echo "Qt5_DIR set to: $QT_PREFIX/lib/cmake/Qt5"
          
      - name: Verify Qt installation
        run: |
          echo "Qt5_DIR: $Qt5_DIR"
          echo "CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
          ls -la "$Qt5_DIR" || echo "Qt5_DIR not found"
          find "$CMAKE_PREFIX_PATH" -name "Qt5GuiConfig.cmake" 2>/dev/null || echo "Qt5GuiConfig.cmake not found"
          find "$CMAKE_PREFIX_PATH" -name "*Qt5*" -type d 2>/dev/null | head -5

      - name: Clone fuego
        run: |
          echo "üîÑ Starting fresh clone of fuego repository..."
          rm -rf cryptonote cryptonote-temp
          echo "üì• Cloning from ColinRitman/fuego master branch..."
          git clone --branch master --depth 1 https://github.com/ColinRitman/fuego.git cryptonote-temp
          mv cryptonote-temp cryptonote
          echo "üìã Verifying cloned repository..."
          git -C cryptonote log --oneline -3
          echo "Current cryptonote commit: $(git -C cryptonote rev-parse HEAD)"
          
          # Verify the memory header fix is present
          if grep -q "#include <memory>" cryptonote/src/WalletLegacy/WalletLegacy.cpp; then
            echo "‚úÖ Memory header fix is present in cloned repository"
          else
            echo "‚ùå Memory header fix is MISSING in cloned repository"
            echo "File contents:"
            head -20 cryptonote/src/WalletLegacy/WalletLegacy.cpp
          fi
          
          # Burn transaction integration files are now in the fuego repository
          echo "‚úÖ Burn transaction integration files are included in the fuego repository"

      # Temporarily disabled XFG STARK CLI to focus on main app
      # - name: Download XFG STARK CLI
      #   run: |
      #     echo "Skipping XFG STARK CLI for now - focusing on main app"

      - name: Fix compilation errors
        run: |
          # Fix serialization issues
          sed -i '' 's/value\.serialize(serializer);/serializer(value);/g' cryptonote/src/Serialization/SerializationOverloads.h
          
          # Fix parallel hashmap issues
          sed -i '' 's/raw_hash_set/flat_hash_set/g' cryptonote/external/parallel_hashmap/phmap_dump.h
          
          # Fix namespace closing brace
          sed -i '' 's/} \/\/ namespace CryptoNote/} \/\/ namespace CryptoNote/g' cryptonote/src/Serialization/SerializationOverloads.h

      - name: Build
        id: build
        run: |
          build_folder="build/release"
          xfg_ver=${GITHUB_SHA::7}
          release_name="fuego-desktop-macOS-apple-silicon-dev-$xfg_ver"
          app_name="FuegoWallet.app"

          # Clean up any existing CMake cache files
          rm -f CMakeCache.txt CMakeCache.txt.*
          rm -rf build/
          
          # Build using CMake (main project, not cryptonote subdirectory)
          mkdir -p build/release
          cd build/release
          
          # ULTIMATE FINAL SOLUTION: Force compiler to use our custom Boost with explicit flags
          cmake ../.. -DCMAKE_PREFIX_PATH="$CMAKE_PREFIX_PATH" -DCMAKE_CXX_STANDARD=17 -DCMAKE_CXX_STANDARD_REQUIRED=ON -DCMAKE_CXX_EXTENSIONS=OFF -DCMAKE_CXX_FLAGS="$CXXFLAGS" -DCMAKE_CXX_COMPILER_FLAGS="$CXXFLAGS" -DCMAKE_EXE_LINKER_FLAGS="$LDFLAGS" -DBOOST_ROOT="$BOOST_ROOT" -DBOOST_INCLUDEDIR="$BOOST_INCLUDEDIR" -DBOOST_LIBRARYDIR="$BOOST_LIBRARYDIR"
          make -j4
          cd ../..
          
          cd build/release
          macdeployqt "$app_name"
          
          # Bundle dependencies for standalone operation
          echo "üì¶ Bundling dependencies..."
          mkdir -p "$app_name/Contents/Frameworks"
          
          # Copy Qt frameworks
          cp -R /opt/homebrew/opt/qt@5/lib/QtCore.framework "$app_name/Contents/Frameworks/"
          cp -R /opt/homebrew/opt/qt@5/lib/QtGui.framework "$app_name/Contents/Frameworks/"
          cp -R /opt/homebrew/opt/qt@5/lib/QtWidgets.framework "$app_name/Contents/Frameworks/"
          cp -R /opt/homebrew/opt/qt@5/lib/QtNetwork.framework "$app_name/Contents/Frameworks/"
          cp -R /opt/homebrew/opt/qt@5/lib/QtCharts.framework "$app_name/Contents/Frameworks/"
          
          # Re-sign the Qt frameworks after modifying them
          echo "üîê Re-signing Qt frameworks after modification..."
          for framework in QtCore QtGui QtWidgets QtNetwork QtCharts QtPrintSupport; do
            if [ -d "$app_name/Contents/Frameworks/${framework}.framework" ]; then
              codesign --force --sign - "$app_name/Contents/Frameworks/${framework}.framework/Versions/5/${framework}"
            fi
          done

          # Copy Boost libraries (try custom first, fallback to system)
          echo "üì¶ Copying Boost libraries..."
          BOOST_LIB_DIR="/opt/homebrew/opt/boost-custom/lib"
          if [ ! -d "$BOOST_LIB_DIR" ] || [ ! -f "$BOOST_LIB_DIR/libboost_program_options.dylib" ]; then
            echo "Custom Boost not found, using system Boost"
            BOOST_LIB_DIR="/opt/homebrew/lib"
          else
            echo "Using custom Boost from $BOOST_LIB_DIR"
          fi
          
          cp "$BOOST_LIB_DIR/libboost_program_options.dylib" "$app_name/Contents/Frameworks/" || echo "Failed to copy libboost_program_options.dylib"
          cp "$BOOST_LIB_DIR/libboost_filesystem.dylib" "$app_name/Contents/Frameworks/" || echo "Failed to copy libboost_filesystem.dylib"
          cp "$BOOST_LIB_DIR/libboost_chrono.dylib" "$app_name/Contents/Frameworks/" || echo "Failed to copy libboost_chrono.dylib"
          cp "$BOOST_LIB_DIR/libboost_atomic.dylib" "$app_name/Contents/Frameworks/" || echo "Failed to copy libboost_atomic.dylib"
          cp "$BOOST_LIB_DIR/libboost_thread.dylib" "$app_name/Contents/Frameworks/" || echo "Failed to copy libboost_thread.dylib"
          cp "$BOOST_LIB_DIR/libboost_serialization.dylib" "$app_name/Contents/Frameworks/" || echo "Failed to copy libboost_serialization.dylib"
          cp "$BOOST_LIB_DIR/libboost_date_time.dylib" "$app_name/Contents/Frameworks/" || echo "Failed to copy libboost_date_time.dylib"
          cp "$BOOST_LIB_DIR/libboost_regex.dylib" "$app_name/Contents/Frameworks/" || echo "Failed to copy libboost_regex.dylib"
          
          # Copy other dependencies
          echo "üì¶ Copying other dependencies..."
          # qrencode is statically linked, so no need to copy it
          if [ -f "/opt/homebrew/lib/libqrencode.dylib" ]; then
            cp /opt/homebrew/lib/libqrencode.dylib "$app_name/Contents/Frameworks/" || echo "Failed to copy libqrencode.dylib"
          else
            echo "qrencode is statically linked, skipping dynamic library copy"
          fi
          cp /opt/homebrew/lib/libminiupnpc.dylib "$app_name/Contents/Frameworks/" || echo "Failed to copy libminiupnpc.dylib"
          
          # Skipping xfg-stark-cli bundling for now - focusing on main app
          
          # Verify icons are in place
          echo "üîç Verifying icons..."
          if [ -f "$app_name/Contents/Resources/fuego.icns" ]; then
            echo "‚úÖ Main app icon (fuego.icns) is present"
          else
            echo "‚ùå Main app icon (fuego.icns) is missing"
          fi
          
          if [ -f "$app_name/Contents/Resources/bin/xfg-stark-cli.icns" ]; then
            echo "‚úÖ xfg-stark-cli icon is present"
          else
            echo "‚ùå xfg-stark-cli icon is missing"
          fi
          
          # Fix library paths dynamically based on actual paths
          echo "üîß Fixing library paths..."
          
          # Fix Qt framework paths dynamically
          for framework in QtCore QtGui QtWidgets QtNetwork QtCharts QtPrintSupport; do
            QT_PATH=$(otool -L "$app_name/Contents/MacOS/FuegoWallet" | grep "${framework}.framework" | awk '{print $1}')
            if [ ! -z "$QT_PATH" ]; then
              echo "Changing $QT_PATH to @executable_path/../Frameworks/${framework}.framework/Versions/5/${framework}"
              install_name_tool -change "$QT_PATH" "@executable_path/../Frameworks/${framework}.framework/Versions/5/${framework}" "$app_name/Contents/MacOS/FuegoWallet"
            else
              echo "No ${framework}.framework found in executable dependencies"
            fi
          done
          
          # Debug: Check what library paths the executable currently has
          echo "üîç Current library dependencies:"
          otool -L "$app_name/Contents/MacOS/FuegoWallet"
          
          # Fix Boost library paths dynamically
          echo "üîß Fixing Boost library paths..."
          for lib in program_options filesystem chrono atomic thread serialization date_time regex; do
            BOOST_PATH=$(otool -L "$app_name/Contents/MacOS/FuegoWallet" | grep "libboost_${lib}.dylib" | awk '{print $1}')
            if [ ! -z "$BOOST_PATH" ]; then
              echo "Changing $BOOST_PATH to @executable_path/../Frameworks/libboost_${lib}.dylib"
              install_name_tool -change "$BOOST_PATH" "@executable_path/../Frameworks/libboost_${lib}.dylib" "$app_name/Contents/MacOS/FuegoWallet"
            else
              echo "No libboost_${lib}.dylib found in executable dependencies"
            fi
          done
          
          # Fix other library paths
          # qrencode is statically linked, so no need to fix its path
          if [ -f "/opt/homebrew/lib/libqrencode.dylib" ]; then
            install_name_tool -change /opt/homebrew/lib/libqrencode.dylib @executable_path/../Frameworks/libqrencode.dylib "$app_name/Contents/MacOS/FuegoWallet"
          else
            echo "qrencode is statically linked, skipping install_name_tool"
          fi
          install_name_tool -change /opt/homebrew/lib/libminiupnpc.dylib @executable_path/../Frameworks/libminiupnpc.dylib "$app_name/Contents/MacOS/FuegoWallet"
          
          # Fix rpath to point to Frameworks directory
          echo "üîß Fixing rpath..."
          install_name_tool -add_rpath "@executable_path/../Frameworks" "$app_name/Contents/MacOS/FuegoWallet"
          # Remove any incorrect rpaths
          install_name_tool -delete_rpath "/opt/homebrew/Cellar/miniupnpc/2.3.3/lib" "$app_name/Contents/MacOS/FuegoWallet" 2>/dev/null || true
          install_name_tool -delete_rpath "/opt/homebrew/lib" "$app_name/Contents/MacOS/FuegoWallet" 2>/dev/null || true
          
          # Verify the library paths were updated correctly
          echo "Final library dependencies:"
          otool -L "$app_name/Contents/MacOS/FuegoWallet"
          
          # Create Info.plist
          echo "üìù Creating Info.plist..."
          cat > "$app_name/Contents/Info.plist" << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleExecutable</key>
              <string>FuegoWallet</string>
              <key>CFBundleIdentifier</key>
              <string>com.fuego.wallet</string>
              <key>CFBundleName</key>
              <string>Fuego Wallet</string>
              <key>CFBundleDisplayName</key>
              <string>Fuego Wallet</string>
              <key>CFBundleVersion</key>
              <string>1.0.0</string>
              <key>CFBundleShortVersionString</key>
              <string>1.0.0</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleSignature</key>
              <string>????</string>
              <key>CFBundleIconFile</key>
              <string>fuego</string>
              <key>LSMinimumSystemVersion</key>
              <string>11.0</string>
              <key>NSHighResolutionCapable</key>
              <true/>
              <key>NSRequiresAquaSystemAppearance</key>
              <false/>
          </dict>
          </plist>
          EOF
          
          # Basic ad-hoc code signing (minimal options)
          echo "üîê Code signing the app bundle..."
          codesign --force --deep --sign - "$app_name"
          
          # Verify the signature
          codesign --verify --verbose "$app_name"
          
          # Test the application
          echo "üß™ Testing application..."
          timeout 10s "./$app_name/Contents/MacOS/FuegoWallet" --version || echo "App test completed"
          
          # Create a tar.gz file to preserve the app bundle structure
          echo "üì¶ Creating tar.gz archive to preserve app bundle structure..."
          tar -czf "${release_name}.tar.gz" "$app_name"
          
          echo "üì¶ App bundle ready: $app_name"
          echo "release_name=${release_name}" >> $GITHUB_OUTPUT
          echo "artifact_path=build/release/${release_name}.tar.gz" >> $GITHUB_OUTPUT

      - name: Upload To GH Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build.outputs.release_name }}
          path: ${{ steps.build.outputs.artifact_path }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}